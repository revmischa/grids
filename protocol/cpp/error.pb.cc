// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "error.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace grids {
namespace message {
namespace error {

namespace {

const ::google::protobuf::Descriptor* CompileError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CompileError_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyNotFound_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyNotFound_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnsupportedSerializer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnsupportedSerializer_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncompatibleVersion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncompatibleVersion_reflection_ = NULL;
const ::google::protobuf::Descriptor* InvalidSerializer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InvalidSerializer_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnknownError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnknownError_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnknownStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnknownStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* Unauthorized_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Unauthorized_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginInvalid_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginInvalid_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_error_2eproto() {
  protobuf_AddDesc_error_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "error.proto");
  GOOGLE_CHECK(file != NULL);
  CompileError_descriptor_ = file->message_type(0);
  static const int CompileError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompileError, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompileError, error_),
  };
  CompileError_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CompileError_descriptor_,
      CompileError::default_instance_,
      CompileError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompileError, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CompileError, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CompileError));
  KeyNotFound_descriptor_ = file->message_type(1);
  static const int KeyNotFound_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyNotFound, base_),
  };
  KeyNotFound_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyNotFound_descriptor_,
      KeyNotFound::default_instance_,
      KeyNotFound_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyNotFound, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyNotFound, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyNotFound));
  UnsupportedSerializer_descriptor_ = file->message_type(2);
  static const int UnsupportedSerializer_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnsupportedSerializer, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnsupportedSerializer, serializer_method_),
  };
  UnsupportedSerializer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnsupportedSerializer_descriptor_,
      UnsupportedSerializer::default_instance_,
      UnsupportedSerializer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnsupportedSerializer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnsupportedSerializer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnsupportedSerializer));
  IncompatibleVersion_descriptor_ = file->message_type(3);
  static const int IncompatibleVersion_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncompatibleVersion, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncompatibleVersion, min_version_),
  };
  IncompatibleVersion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IncompatibleVersion_descriptor_,
      IncompatibleVersion::default_instance_,
      IncompatibleVersion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncompatibleVersion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncompatibleVersion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IncompatibleVersion));
  InvalidSerializer_descriptor_ = file->message_type(4);
  static const int InvalidSerializer_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InvalidSerializer, base_),
  };
  InvalidSerializer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InvalidSerializer_descriptor_,
      InvalidSerializer::default_instance_,
      InvalidSerializer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InvalidSerializer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InvalidSerializer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InvalidSerializer));
  UnknownError_descriptor_ = file->message_type(5);
  static const int UnknownError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownError, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownError, message_),
  };
  UnknownError_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnknownError_descriptor_,
      UnknownError::default_instance_,
      UnknownError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownError, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownError, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnknownError));
  UnknownStatus_descriptor_ = file->message_type(6);
  static const int UnknownStatus_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownStatus, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownStatus, status_),
  };
  UnknownStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnknownStatus_descriptor_,
      UnknownStatus::default_instance_,
      UnknownStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnknownStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnknownStatus));
  Unauthorized_descriptor_ = file->message_type(7);
  static const int Unauthorized_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unauthorized, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unauthorized, message_),
  };
  Unauthorized_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Unauthorized_descriptor_,
      Unauthorized::default_instance_,
      Unauthorized_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unauthorized, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unauthorized, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Unauthorized));
  LoginInvalid_descriptor_ = file->message_type(8);
  static const int LoginInvalid_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginInvalid, base_),
  };
  LoginInvalid_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginInvalid_descriptor_,
      LoginInvalid::default_instance_,
      LoginInvalid_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginInvalid, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginInvalid, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginInvalid));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_error_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CompileError_descriptor_, &CompileError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyNotFound_descriptor_, &KeyNotFound::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnsupportedSerializer_descriptor_, &UnsupportedSerializer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IncompatibleVersion_descriptor_, &IncompatibleVersion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InvalidSerializer_descriptor_, &InvalidSerializer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnknownError_descriptor_, &UnknownError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnknownStatus_descriptor_, &UnknownStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Unauthorized_descriptor_, &Unauthorized::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginInvalid_descriptor_, &LoginInvalid::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_error_2eproto() {
  delete CompileError::default_instance_;
  delete CompileError_reflection_;
  delete KeyNotFound::default_instance_;
  delete KeyNotFound_reflection_;
  delete UnsupportedSerializer::default_instance_;
  delete UnsupportedSerializer_reflection_;
  delete IncompatibleVersion::default_instance_;
  delete IncompatibleVersion_reflection_;
  delete InvalidSerializer::default_instance_;
  delete InvalidSerializer_reflection_;
  delete UnknownError::default_instance_;
  delete UnknownError_reflection_;
  delete UnknownStatus::default_instance_;
  delete UnknownStatus_reflection_;
  delete Unauthorized::default_instance_;
  delete Unauthorized_reflection_;
  delete LoginInvalid::default_instance_;
  delete LoginInvalid_reflection_;
}

void protobuf_AddDesc_error_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::grids::protobuf_AddDesc_base_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013error.proto\022\023grids.message.error\032\nbase"
    ".proto\";\n\014CompileError\022\034\n\004base\030\001 \002(\0132\016.g"
    "rids.Message\022\r\n\005error\030\002 \001(\t\"+\n\013KeyNotFou"
    "nd\022\034\n\004base\030\001 \002(\0132\016.grids.Message\"P\n\025Unsu"
    "pportedSerializer\022\034\n\004base\030\001 \002(\0132\016.grids."
    "Message\022\031\n\021serializer_method\030\002 \001(\t\"H\n\023In"
    "compatibleVersion\022\034\n\004base\030\001 \002(\0132\016.grids."
    "Message\022\023\n\013min_version\030\002 \001(\t\"1\n\021InvalidS"
    "erializer\022\034\n\004base\030\001 \002(\0132\016.grids.Message\""
    "=\n\014UnknownError\022\034\n\004base\030\001 \002(\0132\016.grids.Me"
    "ssage\022\017\n\007message\030\002 \001(\t\"=\n\rUnknownStatus\022"
    "\034\n\004base\030\001 \002(\0132\016.grids.Message\022\016\n\006status\030"
    "\002 \001(\t\"=\n\014Unauthorized\022\034\n\004base\030\001 \002(\0132\016.gr"
    "ids.Message\022\017\n\007message\030\002 \001(\t\",\n\014LoginInv"
    "alid\022\034\n\004base\030\001 \002(\0132\016.grids.Message", 594);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "error.proto", &protobuf_RegisterTypes);
  CompileError::default_instance_ = new CompileError();
  KeyNotFound::default_instance_ = new KeyNotFound();
  UnsupportedSerializer::default_instance_ = new UnsupportedSerializer();
  IncompatibleVersion::default_instance_ = new IncompatibleVersion();
  InvalidSerializer::default_instance_ = new InvalidSerializer();
  UnknownError::default_instance_ = new UnknownError();
  UnknownStatus::default_instance_ = new UnknownStatus();
  Unauthorized::default_instance_ = new Unauthorized();
  LoginInvalid::default_instance_ = new LoginInvalid();
  CompileError::default_instance_->InitAsDefaultInstance();
  KeyNotFound::default_instance_->InitAsDefaultInstance();
  UnsupportedSerializer::default_instance_->InitAsDefaultInstance();
  IncompatibleVersion::default_instance_->InitAsDefaultInstance();
  InvalidSerializer::default_instance_->InitAsDefaultInstance();
  UnknownError::default_instance_->InitAsDefaultInstance();
  UnknownStatus::default_instance_->InitAsDefaultInstance();
  Unauthorized::default_instance_->InitAsDefaultInstance();
  LoginInvalid::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_error_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_error_2eproto {
  StaticDescriptorInitializer_error_2eproto() {
    protobuf_AddDesc_error_2eproto();
  }
} static_descriptor_initializer_error_2eproto_;


// ===================================================================

const ::std::string CompileError::_default_error_;
#ifndef _MSC_VER
const int CompileError::kBaseFieldNumber;
const int CompileError::kErrorFieldNumber;
#endif  // !_MSC_VER

CompileError::CompileError()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CompileError::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

CompileError::CompileError(const CompileError& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CompileError::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  error_ = const_cast< ::std::string*>(&_default_error_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CompileError::~CompileError() {
  SharedDtor();
}

void CompileError::SharedDtor() {
  if (error_ != &_default_error_) {
    delete error_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void CompileError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CompileError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CompileError_descriptor_;
}

const CompileError& CompileError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

CompileError* CompileError::default_instance_ = NULL;

CompileError* CompileError::New() const {
  return new CompileError;
}

void CompileError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
    if (_has_bit(1)) {
      if (error_ != &_default_error_) {
        error_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CompileError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_error;
        break;
      }
      
      // optional string error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->error().data(), this->error().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CompileError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  // optional string error = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->error().data(), this->error().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->error(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CompileError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional string error = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->error().data(), this->error().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->error(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CompileError::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional string error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CompileError::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CompileError* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CompileError*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CompileError::MergeFrom(const CompileError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_error(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CompileError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CompileError::CopyFrom(const CompileError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompileError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void CompileError::Swap(CompileError* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CompileError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CompileError_descriptor_;
  metadata.reflection = CompileError_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyNotFound::kBaseFieldNumber;
#endif  // !_MSC_VER

KeyNotFound::KeyNotFound()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyNotFound::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

KeyNotFound::KeyNotFound(const KeyNotFound& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyNotFound::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyNotFound::~KeyNotFound() {
  SharedDtor();
}

void KeyNotFound::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void KeyNotFound::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyNotFound::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyNotFound_descriptor_;
}

const KeyNotFound& KeyNotFound::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

KeyNotFound* KeyNotFound::default_instance_ = NULL;

KeyNotFound* KeyNotFound::New() const {
  return new KeyNotFound;
}

void KeyNotFound::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyNotFound::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyNotFound::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyNotFound::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyNotFound::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyNotFound::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyNotFound* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyNotFound*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyNotFound::MergeFrom(const KeyNotFound& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyNotFound::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyNotFound::CopyFrom(const KeyNotFound& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyNotFound::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void KeyNotFound::Swap(KeyNotFound* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyNotFound::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyNotFound_descriptor_;
  metadata.reflection = KeyNotFound_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string UnsupportedSerializer::_default_serializer_method_;
#ifndef _MSC_VER
const int UnsupportedSerializer::kBaseFieldNumber;
const int UnsupportedSerializer::kSerializerMethodFieldNumber;
#endif  // !_MSC_VER

UnsupportedSerializer::UnsupportedSerializer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UnsupportedSerializer::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

UnsupportedSerializer::UnsupportedSerializer(const UnsupportedSerializer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UnsupportedSerializer::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  serializer_method_ = const_cast< ::std::string*>(&_default_serializer_method_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnsupportedSerializer::~UnsupportedSerializer() {
  SharedDtor();
}

void UnsupportedSerializer::SharedDtor() {
  if (serializer_method_ != &_default_serializer_method_) {
    delete serializer_method_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void UnsupportedSerializer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnsupportedSerializer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnsupportedSerializer_descriptor_;
}

const UnsupportedSerializer& UnsupportedSerializer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

UnsupportedSerializer* UnsupportedSerializer::default_instance_ = NULL;

UnsupportedSerializer* UnsupportedSerializer::New() const {
  return new UnsupportedSerializer;
}

void UnsupportedSerializer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
    if (_has_bit(1)) {
      if (serializer_method_ != &_default_serializer_method_) {
        serializer_method_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnsupportedSerializer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serializer_method;
        break;
      }
      
      // optional string serializer_method = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serializer_method:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serializer_method()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->serializer_method().data(), this->serializer_method().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnsupportedSerializer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  // optional string serializer_method = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serializer_method().data(), this->serializer_method().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->serializer_method(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UnsupportedSerializer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional string serializer_method = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serializer_method().data(), this->serializer_method().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->serializer_method(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UnsupportedSerializer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional string serializer_method = 2;
    if (has_serializer_method()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serializer_method());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnsupportedSerializer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnsupportedSerializer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnsupportedSerializer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnsupportedSerializer::MergeFrom(const UnsupportedSerializer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_serializer_method(from.serializer_method());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnsupportedSerializer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnsupportedSerializer::CopyFrom(const UnsupportedSerializer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnsupportedSerializer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void UnsupportedSerializer::Swap(UnsupportedSerializer* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(serializer_method_, other->serializer_method_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnsupportedSerializer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnsupportedSerializer_descriptor_;
  metadata.reflection = UnsupportedSerializer_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string IncompatibleVersion::_default_min_version_;
#ifndef _MSC_VER
const int IncompatibleVersion::kBaseFieldNumber;
const int IncompatibleVersion::kMinVersionFieldNumber;
#endif  // !_MSC_VER

IncompatibleVersion::IncompatibleVersion()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IncompatibleVersion::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

IncompatibleVersion::IncompatibleVersion(const IncompatibleVersion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IncompatibleVersion::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  min_version_ = const_cast< ::std::string*>(&_default_min_version_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncompatibleVersion::~IncompatibleVersion() {
  SharedDtor();
}

void IncompatibleVersion::SharedDtor() {
  if (min_version_ != &_default_min_version_) {
    delete min_version_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void IncompatibleVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncompatibleVersion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncompatibleVersion_descriptor_;
}

const IncompatibleVersion& IncompatibleVersion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

IncompatibleVersion* IncompatibleVersion::default_instance_ = NULL;

IncompatibleVersion* IncompatibleVersion::New() const {
  return new IncompatibleVersion;
}

void IncompatibleVersion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
    if (_has_bit(1)) {
      if (min_version_ != &_default_min_version_) {
        min_version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IncompatibleVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_min_version;
        break;
      }
      
      // optional string min_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_min_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->min_version().data(), this->min_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IncompatibleVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  // optional string min_version = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->min_version().data(), this->min_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->min_version(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IncompatibleVersion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional string min_version = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->min_version().data(), this->min_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->min_version(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IncompatibleVersion::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional string min_version = 2;
    if (has_min_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->min_version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncompatibleVersion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IncompatibleVersion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IncompatibleVersion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncompatibleVersion::MergeFrom(const IncompatibleVersion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_min_version(from.min_version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IncompatibleVersion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncompatibleVersion::CopyFrom(const IncompatibleVersion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncompatibleVersion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void IncompatibleVersion::Swap(IncompatibleVersion* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(min_version_, other->min_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IncompatibleVersion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncompatibleVersion_descriptor_;
  metadata.reflection = IncompatibleVersion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InvalidSerializer::kBaseFieldNumber;
#endif  // !_MSC_VER

InvalidSerializer::InvalidSerializer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InvalidSerializer::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

InvalidSerializer::InvalidSerializer(const InvalidSerializer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InvalidSerializer::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InvalidSerializer::~InvalidSerializer() {
  SharedDtor();
}

void InvalidSerializer::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void InvalidSerializer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InvalidSerializer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InvalidSerializer_descriptor_;
}

const InvalidSerializer& InvalidSerializer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

InvalidSerializer* InvalidSerializer::default_instance_ = NULL;

InvalidSerializer* InvalidSerializer::New() const {
  return new InvalidSerializer;
}

void InvalidSerializer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InvalidSerializer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InvalidSerializer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InvalidSerializer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InvalidSerializer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InvalidSerializer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InvalidSerializer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InvalidSerializer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InvalidSerializer::MergeFrom(const InvalidSerializer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InvalidSerializer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InvalidSerializer::CopyFrom(const InvalidSerializer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvalidSerializer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void InvalidSerializer::Swap(InvalidSerializer* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InvalidSerializer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InvalidSerializer_descriptor_;
  metadata.reflection = InvalidSerializer_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string UnknownError::_default_message_;
#ifndef _MSC_VER
const int UnknownError::kBaseFieldNumber;
const int UnknownError::kMessageFieldNumber;
#endif  // !_MSC_VER

UnknownError::UnknownError()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UnknownError::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

UnknownError::UnknownError(const UnknownError& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UnknownError::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  message_ = const_cast< ::std::string*>(&_default_message_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnknownError::~UnknownError() {
  SharedDtor();
}

void UnknownError::SharedDtor() {
  if (message_ != &_default_message_) {
    delete message_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void UnknownError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnknownError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnknownError_descriptor_;
}

const UnknownError& UnknownError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

UnknownError* UnknownError::default_instance_ = NULL;

UnknownError* UnknownError::New() const {
  return new UnknownError;
}

void UnknownError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
    if (_has_bit(1)) {
      if (message_ != &_default_message_) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnknownError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }
      
      // optional string message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnknownError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  // optional string message = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->message(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UnknownError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional string message = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UnknownError::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnknownError::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnknownError* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnknownError*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnknownError::MergeFrom(const UnknownError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnknownError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnknownError::CopyFrom(const UnknownError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnknownError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void UnknownError::Swap(UnknownError* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnknownError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnknownError_descriptor_;
  metadata.reflection = UnknownError_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string UnknownStatus::_default_status_;
#ifndef _MSC_VER
const int UnknownStatus::kBaseFieldNumber;
const int UnknownStatus::kStatusFieldNumber;
#endif  // !_MSC_VER

UnknownStatus::UnknownStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UnknownStatus::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

UnknownStatus::UnknownStatus(const UnknownStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UnknownStatus::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  status_ = const_cast< ::std::string*>(&_default_status_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnknownStatus::~UnknownStatus() {
  SharedDtor();
}

void UnknownStatus::SharedDtor() {
  if (status_ != &_default_status_) {
    delete status_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void UnknownStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnknownStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnknownStatus_descriptor_;
}

const UnknownStatus& UnknownStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

UnknownStatus* UnknownStatus::default_instance_ = NULL;

UnknownStatus* UnknownStatus::New() const {
  return new UnknownStatus;
}

void UnknownStatus::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
    if (_has_bit(1)) {
      if (status_ != &_default_status_) {
        status_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnknownStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_status;
        break;
      }
      
      // optional string status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UnknownStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  // optional string status = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->status(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UnknownStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional string status = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->status(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UnknownStatus::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional string status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnknownStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnknownStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnknownStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnknownStatus::MergeFrom(const UnknownStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnknownStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnknownStatus::CopyFrom(const UnknownStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnknownStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void UnknownStatus::Swap(UnknownStatus* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnknownStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnknownStatus_descriptor_;
  metadata.reflection = UnknownStatus_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Unauthorized::_default_message_;
#ifndef _MSC_VER
const int Unauthorized::kBaseFieldNumber;
const int Unauthorized::kMessageFieldNumber;
#endif  // !_MSC_VER

Unauthorized::Unauthorized()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Unauthorized::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

Unauthorized::Unauthorized(const Unauthorized& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Unauthorized::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  message_ = const_cast< ::std::string*>(&_default_message_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Unauthorized::~Unauthorized() {
  SharedDtor();
}

void Unauthorized::SharedDtor() {
  if (message_ != &_default_message_) {
    delete message_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void Unauthorized::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Unauthorized::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Unauthorized_descriptor_;
}

const Unauthorized& Unauthorized::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

Unauthorized* Unauthorized::default_instance_ = NULL;

Unauthorized* Unauthorized::New() const {
  return new Unauthorized;
}

void Unauthorized::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
    if (_has_bit(1)) {
      if (message_ != &_default_message_) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Unauthorized::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }
      
      // optional string message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Unauthorized::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  // optional string message = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->message(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Unauthorized::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional string message = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Unauthorized::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Unauthorized::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Unauthorized* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Unauthorized*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Unauthorized::MergeFrom(const Unauthorized& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Unauthorized::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Unauthorized::CopyFrom(const Unauthorized& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unauthorized::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void Unauthorized::Swap(Unauthorized* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Unauthorized::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Unauthorized_descriptor_;
  metadata.reflection = Unauthorized_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginInvalid::kBaseFieldNumber;
#endif  // !_MSC_VER

LoginInvalid::LoginInvalid()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginInvalid::InitAsDefaultInstance() {
  base_ = const_cast< ::grids::Message*>(&::grids::Message::default_instance());
}

LoginInvalid::LoginInvalid(const LoginInvalid& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginInvalid::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginInvalid::~LoginInvalid() {
  SharedDtor();
}

void LoginInvalid::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void LoginInvalid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginInvalid::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginInvalid_descriptor_;
}

const LoginInvalid& LoginInvalid::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_error_2eproto();  return *default_instance_;
}

LoginInvalid* LoginInvalid::default_instance_ = NULL;

LoginInvalid* LoginInvalid::New() const {
  return new LoginInvalid;
}

void LoginInvalid::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::grids::Message::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginInvalid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .grids.Message base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginInvalid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->base(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginInvalid::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .grids.Message base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginInvalid::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .grids.Message base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginInvalid::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginInvalid* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginInvalid*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginInvalid::MergeFrom(const LoginInvalid& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::grids::Message::MergeFrom(from.base());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginInvalid::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginInvalid::CopyFrom(const LoginInvalid& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginInvalid::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void LoginInvalid::Swap(LoginInvalid* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginInvalid::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginInvalid_descriptor_;
  metadata.reflection = LoginInvalid_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace error
}  // namespace message
}  // namespace grids

// @@protoc_insertion_point(global_scope)
